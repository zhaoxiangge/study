{"remainingRequest":"J:\\xz_admin_v2\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!J:\\xz_admin_v2\\src\\views\\Home.vue?vue&type=template&id=4fd986d2&scoped=true","dependencies":[{"path":"J:\\xz_admin_v2\\src\\views\\Home.vue","mtime":1556101197035},{"path":"J:\\xz_admin_v2\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1531859503174},{"path":"J:\\xz_admin_v2\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js","mtime":1526010763000},{"path":"J:\\xz_admin_v2\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1531859503174},{"path":"J:\\xz_admin_v2\\node_modules\\vue-loader\\lib\\index.js","mtime":1527860006000}],"contextDependencies":[],"result":["\n<div class=\"home\" style=\"width: 50%;margin-left: 25%;padding-bottom: 500px;\">\n  <!-- <img src=\"../assets/logo.png\"> -->\n  <!-- <HelloWorld msg=\"Welcome to Your Vue.js App\"/> -->\n  <fieldset class=\"fieldset\">\n    <legend>v-model 双向绑定</legend>\n    <div class=\"fieldContent\">\n      <p>{{name}}</p>\n      <input type=\"text\" v-model=\"name\">\n    </div>\n  </fieldset>\n  <fieldset class=\"fieldset\">\n    <legend>Object.freeze() 阻止修改现有的属性，也意味着响应系统无法再_追踪_变化</legend>\n    <div class=\"fieldContent\">\n      <p>{{person.name}}</p>\n      <input type=\"text\" v-model=\"person.name\">\n    </div>\n  </fieldset>\n  <fieldset class=\"fieldset\">\n    <legend>v-once 指令</legend>\n    <div class=\"fieldContent\">\n      <span v-once>这个将不会改变: {{ once }}</span>\n      <p>{{once}}</p>\n      <input type=\"text\" v-model=\"once\">\n    </div>\n  </fieldset>\n  <fieldset class=\"fieldset\">\n    <legend>原始 HTML</legend>\n    <div class=\"fieldContent\">\n      <p>Using mustaches: {{ rawHtml }}</p>\n      <p>Using v-html directive:\n        <span v-html=\"rawHtml\"></span>\n      </p>\n    </div>\n  </fieldset>\n  <fieldset class=\"fieldset\">\n    <legend>修饰符</legend>\n    <div class=\"fieldContent\">\n      <p>v-on:submit.prevent=\"onSubmit\"</p>\n      <form v-on:submit.prevent=\"onSubmit\">...\n        <button type=\"submit\">提交1</button>\n      </form>\n      <p>v-on:submit=\"onSubmit//点击提交左下角有浏览器跳转的加载样字\"</p>\n      <form v-on:submit=\"onSubmit\">...\n        <button type=\"submit\">提交2</button>\n      </form>\n    </div>\n  </fieldset>\n  <fieldset class=\"fieldset\">\n    <legend>计算属性缓存 vs 方法</legend>\n    <div class=\"fieldContent\">\n      <p>计算属性</p>\n      <p>\n        Reversed message:{{computedReversedMessage}}\n      </p>\n      <p>方法</p>\n      <p>Reversed message:{{reversedMessage()}}</p>\n      <p>我们为什么需要缓存？假设我们有一个性能开销比较大的的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代</p>\n    </div>\n  </fieldset>\n  <fieldset class=\"fieldset\">\n    <legend> 侦听属性</legend>\n    <div class=\"fieldContent\">\n      <p>\n        fullName:{{fullName}}\n      </p>\n    </div>\n  </fieldset>\n  <fieldset class=\"fieldset\">\n    <legend> 计算属性的getter和setter</legend>\n    <div class=\"fieldContent\">\n      <p>\n        computedfullName:{{computedfullName}}\n      </p>\n    </div>\n  </fieldset>\n  <fieldset class=\"fieldset\">\n    <legend> 绑定Class </legend>\n    <div class=\"fieldContent\">\n      <div>\n        <button type=\"button\" @click=\"activeHandle\">active</button>\n        <button @click=\"errorHandle\" type=\"button\">error</button>\n        <button type=\"button\" @click=\"noactiveHandle\">noactive</button>\n        <button @click=\"noerrorHandle\" type=\"button\">noerror</button>\n      </div>\n      <p>\n        用计算属性classObject绑定 元素的class只有依赖的值发生变化计算属性才会变化\n        <div v-bind:class=\"classObject\"></div>classObject: {{JSON.stringify(classObject)}}\n      </p>\n    </div>\n  </fieldset>\n  <fieldset class=\"fieldset\">\n    <legend> v-if </legend>\n    <div class=\"fieldContent\">\n      <textarea >\n        在\n        <template> 元素上使用 v-if 条件渲染分组 因为 v-if 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个\n          <template> 元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含\n            <template> 元素。\n      </textarea>\n    </div>\n  </fieldset>\n  <fieldset class=\"fieldset\">\n    <legend> 数组响应式 </legend>\n    <div class=\"fieldContent\">\n      <p v-for=\"item in arr\">\n        {{item}}\n      </p>\n      <p>Vue 包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下： push() pop() shift() unshift() splice() sort() reverse()\n      </p>\n      <p>\n        以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将触发状态更新： \n        <p>\n            // Vue.set Vue.set(vm.items, indexOfItem, newValue) // Array.prototype.splice\n            vm.items.splice(indexOfItem, 1, newValue)\n        </p>\n\n      </p>\n      <p>测试代码:window.viewsHome.$set(window.viewsHome.arr,0,'a1')</p>\n      <p>测试代码:window.viewsHome.arr.splice(0,0,'a0')</p>\n      <textarea style=\"display:block;\">\n          替换数组\n          变异方法 (mutation method)，顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如：filter(), concat() 和 slice() 。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组：\n          \n          example1.items = example1.items.filter(function (item) {\n            return item.message.match(/Foo/)\n          })\n      </textarea>\n    </div>\n  </fieldset>\n</div>\n",null]}