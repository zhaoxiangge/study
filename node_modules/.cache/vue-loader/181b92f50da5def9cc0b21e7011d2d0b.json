{"remainingRequest":"K:\\VUE\\xz_admin_v2\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!K:\\VUE\\xz_admin_v2\\src\\views\\Home.vue?vue&type=style&index=0&id=5e265133&scoped=true&lang=css","dependencies":[{"path":"K:\\VUE\\xz_admin_v2\\src\\views\\Home.vue","mtime":1557382822000},{"path":"K:\\VUE\\xz_admin_v2\\node_modules\\css-loader\\index.js","mtime":499162500000},{"path":"K:\\VUE\\xz_admin_v2\\node_modules\\vue-loader\\lib\\loaders\\stylePostLoader.js","mtime":1521907990000},{"path":"K:\\VUE\\xz_admin_v2\\node_modules\\postcss-loader\\lib\\index.js","mtime":499162500000},{"path":"K:\\VUE\\xz_admin_v2\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1531859504000},{"path":"K:\\VUE\\xz_admin_v2\\node_modules\\vue-loader\\lib\\index.js","mtime":1527860006000}],"contextDependencies":[],"result":["\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.block {\n  padding: 10px;\n  border: 1px solid #CCC;\n}\n",{"version":3,"sources":["Home.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0OA;AACA;AACA;AACA","file":"Home.vue","sourceRoot":"src\\views","sourcesContent":["<template>\n  <div class=\"home page\" >\n    <!-- <img src=\"../assets/logo.png\"> -->\n    <!-- <HelloWorld msg=\"Welcome to Your Vue.js App\"/> -->\n    <fieldset class=\"fieldset\">\n      <legend>v-model 双向绑定</legend>\n      <div class=\"fieldContent\">\n        <p>{{name}}</p>\n        <input type=\"text\" v-model=\"name\">\n      </div>\n    </fieldset>\n    <fieldset class=\"fieldset\">\n      <legend>Object.freeze() 阻止修改现有的属性，也意味着响应系统无法再_追踪_变化</legend>\n      <div class=\"fieldContent\">\n        <p>{{person.name}}</p>\n        <input type=\"text\" v-model=\"person.name\">\n      </div>\n    </fieldset>\n    <fieldset class=\"fieldset\">\n      <legend>v-once 指令</legend>\n      <div class=\"fieldContent\">\n        <span v-once>这个将不会改变: {{ once }}</span>\n        <p>{{once}}</p>\n        <input type=\"text\" v-model=\"once\">\n      </div>\n    </fieldset>\n    <fieldset class=\"fieldset\">\n      <legend>原始 HTML</legend>\n      <div class=\"fieldContent\">\n        <p>Using mustaches: {{ rawHtml }}</p>\n        <p>Using v-html directive:\n          <span v-html=\"rawHtml\"></span>\n        </p>\n      </div>\n    </fieldset>\n    <fieldset class=\"fieldset\">\n      <legend>修饰符</legend>\n      <div class=\"fieldContent\">\n        <p>v-on:submit.prevent=\"onSubmit\"</p>\n        <form v-on:submit.prevent=\"onSubmit\">...\n          <button type=\"submit\">提交1</button>\n        </form>\n        <p>v-on:submit=\"onSubmit//点击提交左下角有浏览器跳转的加载样字\"</p>\n        <form v-on:submit=\"onSubmit\">...\n          <button type=\"submit\">提交2</button>\n        </form>\n      </div>\n    </fieldset>\n    <fieldset class=\"fieldset\">\n      <legend>计算属性缓存 vs 方法</legend>\n      <div class=\"fieldContent\">\n        <p>计算属性</p>\n        <p>\n          Reversed message:{{computedReversedMessage}}\n        </p>\n        <p>方法</p>\n        <p>Reversed message:{{reversedMessage()}}</p>\n        <p>我们为什么需要缓存？假设我们有一个性能开销比较大的的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代</p>\n      </div>\n    </fieldset>\n    <fieldset class=\"fieldset\">\n      <legend> 侦听属性</legend>\n      <div class=\"fieldContent\">\n        <p>\n          fullName:{{fullName}}\n        </p>\n      </div>\n    </fieldset>\n    <fieldset class=\"fieldset\">\n      <legend> 计算属性的getter和setter</legend>\n      <div class=\"fieldContent\">\n        <p>\n          computedfullName:{{computedfullName}}\n        </p>\n      </div>\n    </fieldset>\n    <fieldset class=\"fieldset\">\n      <legend> 绑定Class </legend>\n      <div class=\"fieldContent\">\n        <div>\n          <button type=\"button\" @click=\"activeHandle\">active</button>\n          <button @click=\"errorHandle\" type=\"button\">error</button>\n          <button type=\"button\" @click=\"noactiveHandle\">noactive</button>\n          <button @click=\"noerrorHandle\" type=\"button\">noerror</button>\n        </div>\n        <p>\n          用计算属性classObject绑定 元素的class只有依赖的值发生变化计算属性才会变化\n          <div v-bind:class=\"classObject\"></div>classObject: {{JSON.stringify(classObject)}}\n        </p>\n      </div>\n    </fieldset>\n    <fieldset class=\"fieldset\">\n      <legend> v-if </legend>\n      <div class=\"fieldContent\">\n        <textarea>\n          在\n          <template> 元素上使用 v-if 条件渲染分组 因为 v-if 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个\n            <template> 元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含\n              <template> 元素。\n        </textarea>\n      </div>\n    </fieldset>\n    <fieldset class=\"fieldset\">\n      <legend> 数组响应式 </legend>\n      <div class=\"fieldContent\">\n        <p v-for=\"item in arr\">\n          {{item}}\n        </p>\n        <p>Vue 包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下： push() pop() shift() unshift() splice() sort() reverse()\n        </p>\n        <p>\n          以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将触发状态更新：\n          <p>\n            // Vue.set Vue.set(vm.items, indexOfItem, newValue) // Array.prototype.splice vm.items.splice(indexOfItem, 1, newValue)\n          </p>\n\n        </p>\n        <p>测试代码:window.viewsHome.$set(window.viewsHome.arr,0,'a1')</p>\n        <p>测试代码:window.viewsHome.arr.splice(0,0,'a0')</p>\n        <textarea style=\"display:block;\">\n          替换数组 变异方法 (mutation method)，顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如：filter(), concat() 和 slice() 。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组：\n          example1.items = example1.items.filter(function (item) { return item.message.match(/Foo/) })\n        </textarea>\n      </div>\n    </fieldset>\n    <fieldset class=\"fieldset\">\n      <legend> v-on:click.prevent.self 和 v-on:click.self.prevent</legend>\n      <div class=\"fieldContent\">\n        <p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。</p>\n        <p>自己的理解:修饰符连着写 是且的关系,不是并列关系, </p>\n        <p>click.prevent.self:先阻止默认行为,然后判断是否点击的自己</p>\n        <p>click.self.prevent:如果判断点击的自己,执行click绑定的方法,阻止默认行为,如果点击不是自己,例如当事件冒泡到自己时,不执行click绑定的方法,且没有阻止默认行为,如果这个元素a元素的话,会跳转,是提交按钮的话会提交表单</p>\n      </div>\n    </fieldset>\n  </div>\n  </template>\n\n  <script>\n    // @ is an alias to /src\n    // import HelloWorld from '@/components/HelloWorld.vue'\n    const person = {\n      name: '没有响应式的小当'\n    };\n    Object.freeze(person);\n    export default {\n      name: 'home',\n      data() {\n        return {\n          name: '小明',\n          once: 'once',\n          person: person,\n          rawHtml: '<span style=\"color: red\">This should be red.</span>',\n          message: 'Hello',\n          firstName: 'Foo',\n          lastName: 'Bar',\n          fullName: 'Foo Bar',\n          //计算属性绑定class 依赖的内部变量\n          isActive: true,\n          error: null,\n          arr: ['a', 'b', 'c'],\n        }\n      },\n      computed: {\n        //绑定class的计算属性 常用且强大的模式\n        classObject: function () {\n          return {\n            active: this.isActive && !this.error,\n            'text-danger': this.error && this.error.type === 'fatal'\n          }\n        },\n        // 计算属性的 getter\n        computedReversedMessage: function () {\n          // `this` 指向 vm 实例\n          return this.message.split('').reverse().join('')\n        },\n        computedfullName: {\n          // getter\n          get: function () {\n            return this.firstName + ' ' + this.lastName\n          },\n          // setter\n          set: function (newValue) {\n            var names = newValue.split(' ')\n            this.firstName = names[0]\n            this.lastName = names[names.length - 1]\n          }\n        },\n      },\n      watch: {\n        firstName: function (val) {\n          this.fullName = val + ' ' + this.lastName\n        },\n        lastName: function (val) {\n          this.fullName = this.firstName + ' ' + val\n        }\n      },\n      created: function () {\n      },\n      methods: {\n        click1:function(){\n          alert('v-on:click.prevent.self')\n        },\n        click2:function(){\n          alert('v-on:click.self.prevent')\n        },\n        click3:function(){\n          alert('click3')\n        },\n        activeHandle: function () {\n          this.active = true;\n        },\n        errorHandle: function () {\n          this.error = true;\n        },\n        noactiveHandle: function () {\n          this.active = false;\n        },\n        noerrorHandle: function () {\n          this.error = false;\n        },\n        onSubmit: function () {\n          console.log('onSubmit');\n        },\n        reversedMessage: function () {\n          return this.message.split('').reverse().join('')\n        },\n      },\n      components: {\n        // HelloWorld\n\n      }\n    }\n  </script>\n  <style scoped>\n    .block {\n      padding: 10px;\n      border: 1px solid #CCC;\n    }\n  </style>\n"]}]}