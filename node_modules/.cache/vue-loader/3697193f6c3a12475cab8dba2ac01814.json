{"remainingRequest":"J:\\myVue\\xz_admin_v2\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js??vue-loader-options!J:\\myVue\\xz_admin_v2\\node_modules\\cache-loader\\dist\\cjs.js??ref--0-0!J:\\myVue\\xz_admin_v2\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!J:\\myVue\\xz_admin_v2\\src\\views\\Home.vue?vue&type=template&id=5e265133&scoped=true","dependencies":[{"path":"J:\\myVue\\xz_admin_v2\\src\\views\\Home.vue","mtime":1557382822000},{"path":"J:\\myVue\\xz_admin_v2\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1531859504000},{"path":"J:\\myVue\\xz_admin_v2\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js","mtime":1526010764000},{"path":"J:\\myVue\\xz_admin_v2\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1531859504000},{"path":"J:\\myVue\\xz_admin_v2\\node_modules\\vue-loader\\lib\\index.js","mtime":1527860006000}],"contextDependencies":[],"result":["var render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"div\", { staticClass: \"home page\" }, [\n    _c(\"fieldset\", { staticClass: \"fieldset\" }, [\n      _c(\"legend\", [_vm._v(\"v-model 双向绑定\")]),\n      _c(\"div\", { staticClass: \"fieldContent\" }, [\n        _c(\"p\", [_vm._v(_vm._s(_vm.name))]),\n        _c(\"input\", {\n          directives: [\n            {\n              name: \"model\",\n              rawName: \"v-model\",\n              value: _vm.name,\n              expression: \"name\"\n            }\n          ],\n          attrs: { type: \"text\" },\n          domProps: { value: _vm.name },\n          on: {\n            input: function($event) {\n              if ($event.target.composing) {\n                return\n              }\n              _vm.name = $event.target.value\n            }\n          }\n        })\n      ])\n    ]),\n    _c(\"fieldset\", { staticClass: \"fieldset\" }, [\n      _c(\"legend\", [\n        _vm._v(\n          \"Object.freeze() 阻止修改现有的属性，也意味着响应系统无法再_追踪_变化\"\n        )\n      ]),\n      _c(\"div\", { staticClass: \"fieldContent\" }, [\n        _c(\"p\", [_vm._v(_vm._s(_vm.person.name))]),\n        _c(\"input\", {\n          directives: [\n            {\n              name: \"model\",\n              rawName: \"v-model\",\n              value: _vm.person.name,\n              expression: \"person.name\"\n            }\n          ],\n          attrs: { type: \"text\" },\n          domProps: { value: _vm.person.name },\n          on: {\n            input: function($event) {\n              if ($event.target.composing) {\n                return\n              }\n              _vm.$set(_vm.person, \"name\", $event.target.value)\n            }\n          }\n        })\n      ])\n    ]),\n    _c(\"fieldset\", { staticClass: \"fieldset\" }, [\n      _c(\"legend\", [_vm._v(\"v-once 指令\")]),\n      _c(\"div\", { staticClass: \"fieldContent\" }, [\n        _vm._m(0),\n        _c(\"p\", [_vm._v(_vm._s(_vm.once))]),\n        _c(\"input\", {\n          directives: [\n            {\n              name: \"model\",\n              rawName: \"v-model\",\n              value: _vm.once,\n              expression: \"once\"\n            }\n          ],\n          attrs: { type: \"text\" },\n          domProps: { value: _vm.once },\n          on: {\n            input: function($event) {\n              if ($event.target.composing) {\n                return\n              }\n              _vm.once = $event.target.value\n            }\n          }\n        })\n      ])\n    ]),\n    _c(\"fieldset\", { staticClass: \"fieldset\" }, [\n      _c(\"legend\", [_vm._v(\"原始 HTML\")]),\n      _c(\"div\", { staticClass: \"fieldContent\" }, [\n        _c(\"p\", [_vm._v(\"Using mustaches: \" + _vm._s(_vm.rawHtml))]),\n        _c(\"p\", [\n          _vm._v(\"Using v-html directive:\\n        \"),\n          _c(\"span\", { domProps: { innerHTML: _vm._s(_vm.rawHtml) } })\n        ])\n      ])\n    ]),\n    _c(\"fieldset\", { staticClass: \"fieldset\" }, [\n      _c(\"legend\", [_vm._v(\"修饰符\")]),\n      _c(\"div\", { staticClass: \"fieldContent\" }, [\n        _c(\"p\", [_vm._v('v-on:submit.prevent=\"onSubmit\"')]),\n        _c(\n          \"form\",\n          {\n            on: {\n              submit: function($event) {\n                $event.preventDefault()\n                return _vm.onSubmit($event)\n              }\n            }\n          },\n          [\n            _vm._v(\"...\\n        \"),\n            _c(\"button\", { attrs: { type: \"submit\" } }, [_vm._v(\"提交1\")])\n          ]\n        ),\n        _c(\"p\", [\n          _vm._v('v-on:submit=\"onSubmit//点击提交左下角有浏览器跳转的加载样字\"')\n        ]),\n        _c(\"form\", { on: { submit: _vm.onSubmit } }, [\n          _vm._v(\"...\\n        \"),\n          _c(\"button\", { attrs: { type: \"submit\" } }, [_vm._v(\"提交2\")])\n        ])\n      ])\n    ]),\n    _c(\"fieldset\", { staticClass: \"fieldset\" }, [\n      _c(\"legend\", [_vm._v(\"计算属性缓存 vs 方法\")]),\n      _c(\"div\", { staticClass: \"fieldContent\" }, [\n        _c(\"p\", [_vm._v(\"计算属性\")]),\n        _c(\"p\", [\n          _vm._v(\n            \"\\n        Reversed message:\" +\n              _vm._s(_vm.computedReversedMessage) +\n              \"\\n      \"\n          )\n        ]),\n        _c(\"p\", [_vm._v(\"方法\")]),\n        _c(\"p\", [_vm._v(\"Reversed message:\" + _vm._s(_vm.reversedMessage()))]),\n        _c(\"p\", [\n          _vm._v(\n            \"我们为什么需要缓存？假设我们有一个性能开销比较大的的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代\"\n          )\n        ])\n      ])\n    ]),\n    _c(\"fieldset\", { staticClass: \"fieldset\" }, [\n      _c(\"legend\", [_vm._v(\" 侦听属性\")]),\n      _c(\"div\", { staticClass: \"fieldContent\" }, [\n        _c(\"p\", [\n          _vm._v(\"\\n        fullName:\" + _vm._s(_vm.fullName) + \"\\n      \")\n        ])\n      ])\n    ]),\n    _c(\"fieldset\", { staticClass: \"fieldset\" }, [\n      _c(\"legend\", [_vm._v(\" 计算属性的getter和setter\")]),\n      _c(\"div\", { staticClass: \"fieldContent\" }, [\n        _c(\"p\", [\n          _vm._v(\n            \"\\n        computedfullName:\" +\n              _vm._s(_vm.computedfullName) +\n              \"\\n      \"\n          )\n        ])\n      ])\n    ]),\n    _c(\"fieldset\", { staticClass: \"fieldset\" }, [\n      _c(\"legend\", [_vm._v(\" 绑定Class \")]),\n      _c(\"div\", { staticClass: \"fieldContent\" }, [\n        _c(\"div\", [\n          _c(\n            \"button\",\n            { attrs: { type: \"button\" }, on: { click: _vm.activeHandle } },\n            [_vm._v(\"active\")]\n          ),\n          _c(\n            \"button\",\n            { attrs: { type: \"button\" }, on: { click: _vm.errorHandle } },\n            [_vm._v(\"error\")]\n          ),\n          _c(\n            \"button\",\n            { attrs: { type: \"button\" }, on: { click: _vm.noactiveHandle } },\n            [_vm._v(\"noactive\")]\n          ),\n          _c(\n            \"button\",\n            { attrs: { type: \"button\" }, on: { click: _vm.noerrorHandle } },\n            [_vm._v(\"noerror\")]\n          )\n        ]),\n        _c(\"p\", [\n          _vm._v(\n            \"\\n        用计算属性classObject绑定 元素的class只有依赖的值发生变化计算属性才会变化\\n        \"\n          )\n        ]),\n        _c(\"div\", { class: _vm.classObject }),\n        _vm._v(\n          \"classObject: \" + _vm._s(JSON.stringify(_vm.classObject)) + \"\\n      \"\n        ),\n        _c(\"p\")\n      ])\n    ]),\n    _vm._m(1),\n    _c(\"fieldset\", { staticClass: \"fieldset\" }, [\n      _c(\"legend\", [_vm._v(\" 数组响应式 \")]),\n      _c(\n        \"div\",\n        { staticClass: \"fieldContent\" },\n        [\n          _vm._l(_vm.arr, function(item) {\n            return _c(\"p\", [_vm._v(\"\\n        \" + _vm._s(item) + \"\\n      \")])\n          }),\n          _c(\"p\", [\n            _vm._v(\n              \"Vue 包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下： push() pop() shift() unshift() splice() sort() reverse()\\n      \"\n            )\n          ]),\n          _c(\"p\", [\n            _vm._v(\n              \"\\n        以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将触发状态更新：\\n        \"\n            )\n          ]),\n          _c(\"p\", [\n            _vm._v(\n              \"\\n          // Vue.set Vue.set(vm.items, indexOfItem, newValue) // Array.prototype.splice vm.items.splice(indexOfItem, 1, newValue)\\n        \"\n            )\n          ]),\n          _c(\"p\"),\n          _c(\"p\", [\n            _vm._v(\n              \"测试代码:window.viewsHome.$set(window.viewsHome.arr,0,'a1')\"\n            )\n          ]),\n          _c(\"p\", [_vm._v(\"测试代码:window.viewsHome.arr.splice(0,0,'a0')\")]),\n          _c(\"textarea\", { staticStyle: { display: \"block\" } }, [\n            _vm._v(\n              \"        替换数组 变异方法 (mutation method)，顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如：filter(), concat() 和 slice() 。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组：\\n        example1.items = example1.items.filter(function (item) { return item.message.match(/Foo/) })\\n      \"\n            )\n          ])\n        ],\n        2\n      )\n    ]),\n    _vm._m(2)\n  ])\n}\nvar staticRenderFns = [\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"span\", [_vm._v(\"这个将不会改变: \" + _vm._s(_vm.once))])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"fieldset\", { staticClass: \"fieldset\" }, [\n      _c(\"legend\", [_vm._v(\" v-if \")]),\n      _c(\"div\", { staticClass: \"fieldContent\" }, [\n        _c(\"textarea\", [\n          _vm._v(\n            \"        在\\n        <template> 元素上使用 v-if 条件渲染分组 因为 v-if 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个\\n          <template> 元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含\\n            <template> 元素。\\n      \"\n          )\n        ])\n      ])\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"fieldset\", { staticClass: \"fieldset\" }, [\n      _c(\"legend\", [\n        _vm._v(\" v-on:click.prevent.self 和 v-on:click.self.prevent\")\n      ]),\n      _c(\"div\", { staticClass: \"fieldContent\" }, [\n        _c(\"p\", [\n          _vm._v(\n            \"使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。\"\n          )\n        ]),\n        _c(\"p\", [_vm._v(\"自己的理解:修饰符连着写 是且的关系,不是并列关系, \")]),\n        _c(\"p\", [\n          _vm._v(\"click.prevent.self:先阻止默认行为,然后判断是否点击的自己\")\n        ]),\n        _c(\"p\", [\n          _vm._v(\n            \"click.self.prevent:如果判断点击的自己,执行click绑定的方法,阻止默认行为,如果点击不是自己,例如当事件冒泡到自己时,不执行click绑定的方法,且没有阻止默认行为,如果这个元素a元素的话,会跳转,是提交按钮的话会提交表单\"\n          )\n        ])\n      ])\n    ])\n  }\n]\nrender._withStripped = true\n\nexport { render, staticRenderFns }"]}