{"remainingRequest":"J:\\xz_admin_v2\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js??vue-loader-options!J:\\xz_admin_v2\\node_modules\\cache-loader\\dist\\cjs.js??ref--0-0!J:\\xz_admin_v2\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!J:\\xz_admin_v2\\src\\views\\About.vue?vue&type=template&id=c9ad842e","dependencies":[{"path":"J:\\xz_admin_v2\\src\\views\\About.vue","mtime":1557385708962},{"path":"J:\\xz_admin_v2\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1531859503174},{"path":"J:\\xz_admin_v2\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js","mtime":1526010763000},{"path":"J:\\xz_admin_v2\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1531859503174},{"path":"J:\\xz_admin_v2\\node_modules\\vue-loader\\lib\\index.js","mtime":1527860006000}],"contextDependencies":[],"result":["var render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"div\", { staticClass: \"about page\" }, [\n    _c(\"input\", {\n      staticStyle: { width: \"100%\" },\n      attrs: {\n        placeholder: \"下边输入框使用了自定义的全局指令 v-focus\",\n        type: \"number\",\n        name: \"\",\n        id: \"\"\n      }\n    }),\n    _c(\"input\", {\n      directives: [{ name: \"focus\", rawName: \"v-focus\" }],\n      attrs: { type: \"number\", name: \"\", id: \"\" }\n    }),\n    _c(\"input\", {\n      directives: [\n        { name: \"directivesTest1\", rawName: \"v-directivesTest1\" },\n        { name: \"directivesTest2\", rawName: \"v-directivesTest2\" }\n      ],\n      attrs: { type: \"number\", name: \"\", id: \"\" }\n    }),\n    _vm._m(0),\n    _c(\n      \"textarea\",\n      { attrs: { name: \"\", id: \"about\", cols: \"90\", rows: \"100\" } },\n      [\n        _vm._v(\n          \"    在编写组件时，最好考虑好以后是否要进行复用。一次性组件间有紧密的耦合没关系，但是可复用组件应当定义一个清晰的公开接口，同时也不要对其使用的外层数据作出任何假设。 Vue 组件的 API 来自三部分——prop、事件和插槽： Prop 允许外部环境传递数据给组件；\\n    事件允许从组件内触发外部环境的副作用； 插槽允许外部环境将额外的内容组合在组件中。 子组件引用 尽管有 prop 和事件，但是有时仍然需要在 JavaScript 中直接访问子组件。为此可以使用 ref 为子组件指定一个引用 ID。例如：\\n\\n    <div id=\\\"parent\\\">\\n      <user-profile ref=\\\"profile\\\"></user-profile>\\n    </div>\\n    var parent = new Vue({ el: '#parent' }) // 访问子组件实例 var child = parent.$refs.profile 当 ref 和 v-for 一起使用时，获取到的引用会是一个数组，包含和循环数据源对应的子组件。\\n    $refs 只在组件渲染完成后才填充，并且它是非响应式的。它仅仅是一个直接操作子组件的应急方案——应当避免在模板或计算属性中使用 $refs。 对低开销的静态组件使用 v-once 尽管在 Vue 中渲染 HTML 很快，不过当组件中包含大量静态内容时，可以考虑使用\\n    v-once 将渲染结果缓存起来，就像这样： Vue.component('terms-of-service', { template: '\\\\\\n    <div v-once>\\\\\\n      <h1>Terms of Service</h1>\\\\ ...很多静态内容...\\\\\\n    </div>\\\\ ' }) 全局混入 在main.js里使用了混入 //全局混入 Vue.mixin({ created: function () { //每个vue实例对象 都赋给 window下的全局变量,可以测试用; //如果每个组件的name都严格按照\\n    src下的 文件目录+文件名来命名,则可把所有vue实例赋给全局变量,每个组件都能方便使用其他vue实例 window['_' + this.$options.name + '_' + this._uid] = this; } })\\n    也可以全局注册混入对象。注意使用！ 一旦使用全局混入对象，将会影响到 所有 之后创建的 Vue 实例。使用恰当时，可以为自定义对象注入处理逻辑。 // 为自定义的选项 'myOption' 注入一个处理器。 Vue.mixin({\\n    created: function () { var myOption = this.$options.myOption if (myOption) { console.log(myOption) } } }) new Vue({\\n    myOption: 'hello!' }) // => \\\"hello!\\\"\\n  \"\n        )\n      ]\n    )\n  ])\n}\nvar staticRenderFns = [\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"h3\", [\n      _c(\"span\", [\n        _vm._v(\n          \"学到自定义指令,觉得可以用自定义指令 来实现 特定框,在inserted钩子函数中对元素本身做控制,比如按键事件控制能输入的范围,最大长度,以及其他控制(手机号框,放大镜框,双敲复核框...)\"\n        )\n      ])\n    ])\n  }\n]\nrender._withStripped = true\n\nexport { render, staticRenderFns }"]}