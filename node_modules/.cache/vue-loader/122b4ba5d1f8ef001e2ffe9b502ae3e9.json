{"remainingRequest":"K:\\VUE\\xz_admin_v2\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js??vue-loader-options!K:\\VUE\\xz_admin_v2\\node_modules\\cache-loader\\dist\\cjs.js??ref--0-0!K:\\VUE\\xz_admin_v2\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!K:\\VUE\\xz_admin_v2\\src\\views\\Home.vue?vue&type=template&id=5dc3cf06&scoped=true","dependencies":[{"path":"K:\\VUE\\xz_admin_v2\\src\\views\\Home.vue","mtime":1557382820226},{"path":"K:\\VUE\\xz_admin_v2\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1531859503174},{"path":"K:\\VUE\\xz_admin_v2\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js","mtime":1526010763000},{"path":"K:\\VUE\\xz_admin_v2\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1531859503174},{"path":"K:\\VUE\\xz_admin_v2\\node_modules\\vue-loader\\lib\\index.js","mtime":1527860006000}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"home page\"},[_c('fieldset',{staticClass:\"fieldset\"},[_c('legend',[_vm._v(\"v-model 双向绑定\")]),_c('div',{staticClass:\"fieldContent\"},[_c('p',[_vm._v(_vm._s(_vm.name))]),_c('input',{directives:[{name:\"model\",rawName:\"v-model\",value:(_vm.name),expression:\"name\"}],attrs:{\"type\":\"text\"},domProps:{\"value\":(_vm.name)},on:{\"input\":function($event){if($event.target.composing){ return; }_vm.name=$event.target.value}}})])]),_c('fieldset',{staticClass:\"fieldset\"},[_c('legend',[_vm._v(\"Object.freeze() 阻止修改现有的属性，也意味着响应系统无法再_追踪_变化\")]),_c('div',{staticClass:\"fieldContent\"},[_c('p',[_vm._v(_vm._s(_vm.person.name))]),_c('input',{directives:[{name:\"model\",rawName:\"v-model\",value:(_vm.person.name),expression:\"person.name\"}],attrs:{\"type\":\"text\"},domProps:{\"value\":(_vm.person.name)},on:{\"input\":function($event){if($event.target.composing){ return; }_vm.$set(_vm.person, \"name\", $event.target.value)}}})])]),_c('fieldset',{staticClass:\"fieldset\"},[_c('legend',[_vm._v(\"v-once 指令\")]),_c('div',{staticClass:\"fieldContent\"},[_vm._m(0),_c('p',[_vm._v(_vm._s(_vm.once))]),_c('input',{directives:[{name:\"model\",rawName:\"v-model\",value:(_vm.once),expression:\"once\"}],attrs:{\"type\":\"text\"},domProps:{\"value\":(_vm.once)},on:{\"input\":function($event){if($event.target.composing){ return; }_vm.once=$event.target.value}}})])]),_c('fieldset',{staticClass:\"fieldset\"},[_c('legend',[_vm._v(\"原始 HTML\")]),_c('div',{staticClass:\"fieldContent\"},[_c('p',[_vm._v(\"Using mustaches: \"+_vm._s(_vm.rawHtml))]),_c('p',[_vm._v(\"Using v-html directive:\\n        \"),_c('span',{domProps:{\"innerHTML\":_vm._s(_vm.rawHtml)}})])])]),_c('fieldset',{staticClass:\"fieldset\"},[_c('legend',[_vm._v(\"修饰符\")]),_c('div',{staticClass:\"fieldContent\"},[_c('p',[_vm._v(\"v-on:submit.prevent=\\\"onSubmit\\\"\")]),_c('form',{on:{\"submit\":function($event){$event.preventDefault();return _vm.onSubmit($event)}}},[_vm._v(\"...\\n        \"),_c('button',{attrs:{\"type\":\"submit\"}},[_vm._v(\"提交1\")])]),_c('p',[_vm._v(\"v-on:submit=\\\"onSubmit//点击提交左下角有浏览器跳转的加载样字\\\"\")]),_c('form',{on:{\"submit\":_vm.onSubmit}},[_vm._v(\"...\\n        \"),_c('button',{attrs:{\"type\":\"submit\"}},[_vm._v(\"提交2\")])])])]),_c('fieldset',{staticClass:\"fieldset\"},[_c('legend',[_vm._v(\"计算属性缓存 vs 方法\")]),_c('div',{staticClass:\"fieldContent\"},[_c('p',[_vm._v(\"计算属性\")]),_c('p',[_vm._v(\"\\n        Reversed message:\"+_vm._s(_vm.computedReversedMessage)+\"\\n      \")]),_c('p',[_vm._v(\"方法\")]),_c('p',[_vm._v(\"Reversed message:\"+_vm._s(_vm.reversedMessage()))]),_c('p',[_vm._v(\"我们为什么需要缓存？假设我们有一个性能开销比较大的的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代\")])])]),_c('fieldset',{staticClass:\"fieldset\"},[_c('legend',[_vm._v(\" 侦听属性\")]),_c('div',{staticClass:\"fieldContent\"},[_c('p',[_vm._v(\"\\n        fullName:\"+_vm._s(_vm.fullName)+\"\\n      \")])])]),_c('fieldset',{staticClass:\"fieldset\"},[_c('legend',[_vm._v(\" 计算属性的getter和setter\")]),_c('div',{staticClass:\"fieldContent\"},[_c('p',[_vm._v(\"\\n        computedfullName:\"+_vm._s(_vm.computedfullName)+\"\\n      \")])])]),_c('fieldset',{staticClass:\"fieldset\"},[_c('legend',[_vm._v(\" 绑定Class \")]),_c('div',{staticClass:\"fieldContent\"},[_c('div',[_c('button',{attrs:{\"type\":\"button\"},on:{\"click\":_vm.activeHandle}},[_vm._v(\"active\")]),_c('button',{attrs:{\"type\":\"button\"},on:{\"click\":_vm.errorHandle}},[_vm._v(\"error\")]),_c('button',{attrs:{\"type\":\"button\"},on:{\"click\":_vm.noactiveHandle}},[_vm._v(\"noactive\")]),_c('button',{attrs:{\"type\":\"button\"},on:{\"click\":_vm.noerrorHandle}},[_vm._v(\"noerror\")])]),_c('p',[_vm._v(\"\\n        用计算属性classObject绑定 元素的class只有依赖的值发生变化计算属性才会变化\\n        \")]),_c('div',{class:_vm.classObject}),_vm._v(\"classObject: \"+_vm._s(JSON.stringify(_vm.classObject))+\"\\n      \"),_c('p')])]),_vm._m(1),_c('fieldset',{staticClass:\"fieldset\"},[_c('legend',[_vm._v(\" 数组响应式 \")]),_c('div',{staticClass:\"fieldContent\"},[_vm._l((_vm.arr),function(item){return _c('p',[_vm._v(\"\\n        \"+_vm._s(item)+\"\\n      \")])}),_c('p',[_vm._v(\"Vue 包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下： push() pop() shift() unshift() splice() sort() reverse()\\n      \")]),_c('p',[_vm._v(\"\\n        以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将触发状态更新：\\n        \")]),_c('p',[_vm._v(\"\\n          // Vue.set Vue.set(vm.items, indexOfItem, newValue) // Array.prototype.splice vm.items.splice(indexOfItem, 1, newValue)\\n        \")]),_c('p'),_c('p',[_vm._v(\"测试代码:window.viewsHome.$set(window.viewsHome.arr,0,'a1')\")]),_c('p',[_vm._v(\"测试代码:window.viewsHome.arr.splice(0,0,'a0')\")]),_c('textarea',{staticStyle:{\"display\":\"block\"}},[_vm._v(\"        替换数组 变异方法 (mutation method)，顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如：filter(), concat() 和 slice() 。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组：\\n        example1.items = example1.items.filter(function (item) { return item.message.match(/Foo/) })\\n      \")])],2)]),_vm._m(2)])}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',[_vm._v(\"这个将不会改变: \"+_vm._s(_vm.once))])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('fieldset',{staticClass:\"fieldset\"},[_c('legend',[_vm._v(\" v-if \")]),_c('div',{staticClass:\"fieldContent\"},[_c('textarea',[_vm._v(\"        在\\n        <template> 元素上使用 v-if 条件渲染分组 因为 v-if 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个\\n          <template> 元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含\\n            <template> 元素。\\n      \")])])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('fieldset',{staticClass:\"fieldset\"},[_c('legend',[_vm._v(\" v-on:click.prevent.self 和 v-on:click.self.prevent\")]),_c('div',{staticClass:\"fieldContent\"},[_c('p',[_vm._v(\"使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。\")]),_c('p',[_vm._v(\"自己的理解:修饰符连着写 是且的关系,不是并列关系, \")]),_c('p',[_vm._v(\"click.prevent.self:先阻止默认行为,然后判断是否点击的自己\")]),_c('p',[_vm._v(\"click.self.prevent:如果判断点击的自己,执行click绑定的方法,阻止默认行为,如果点击不是自己,例如当事件冒泡到自己时,不执行click绑定的方法,且没有阻止默认行为,如果这个元素a元素的话,会跳转,是提交按钮的话会提交表单\")])])])}]\n\nexport { render, staticRenderFns }"]}